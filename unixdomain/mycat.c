/*******************************************************************
 * my_open为核心函数，程序mycat：
 * 
 *   1）调用socketpair创建一个流管道
 *
 *   -------------
 *  |    mycat    |
 *  |  [0]   [1]  |
 *   ---*-----*---
 *     /|\   /|\   
 *      |     |
 *       -----
 * 
 *  2）fork子进程，子进程调用exec执行openfile程序。父进程关闭[1]描述符，
 *     子进程关闭[0]描述符（也可以反过来）
 *
 *       -------------------------------
 *      \|/                             |
 *     mycat                         openfile
 *  -----------      fork,         ------------
 * |           |_______________>  |            |
 * | [0]       |                  |         [1]|
 *  -*---------  exec(命令行参数)    ----------*-
 *  /|\                                     /|\
 *   |              <-描述符                  |
 *    ---------------------------------------
 *
 *   父进程必须给openfile程序传递3条信息：
 *      a）待打开文件的路径名
 *      b）打开方式
 *      c）流管道本进程端对应的描述符号
 *
 *   通过执行另一个程序来打开文件的优势在于：另一个程序可以是一个setuid到root
 *   的程序，能够打开我们通常没有打开权限的文件。该程序能够把通常的Unix权限概念
 *   扩展到它想要的任何形式的访问检查
 *******************************************************************/

#include	"unp.h"

int		my_open(const char *, int);

int
main(int argc, char **argv)
{
	int		fd, n;
	char	buff[BUFFSIZE];

	if (argc != 2)
		err_quit("usage: mycat <pathname>");

	//my_open创建一个流管道，并调用fork和exec启动执行另一个程序，
	//期待输出的文件由这个程序新程序打开，该程序随后必须把打开的描
	//述符通过流管道传递回父进程
	if ( (fd = my_open(argv[1], O_RDONLY)) < 0)
		err_sys("cannot open %s", argv[1]);

	while ( (n = Read(fd, buff, BUFFSIZE)) > 0)
		Write(STDOUT_FILENO, buff, n);

	exit(0);
}
